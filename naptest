#!/usr/bin/python3
#naptest- not another pentest!

import sys,sqlite3 as lite,os,argparse,ast

#initiate argparsing
parser = argparse.ArgumentParser()
parser = argparse.ArgumentParser(description="naptest- a framework to assist with security assessments.")
parser.add_argument("xml", help="Path to the nmap XML output. Either a file or folder.")
parser.add_argument("-o" , "--output", help="Directory for output", default="./")
parser.add_argument("-m" , "--mode", help="Mode to run in: parse, monitor, test", default="parse")
global args
args = parser.parse_args()

#Magic Variables
dbfile="naptest.db"
svcarrayfile="services.array"
svcfolder="services"

global servicearray
servicearray = {}
db = os.path.join(args.output, dbfile)

def nmap_xml_monitor(nmapdir):
    import re
    import xml.etree.ElementTree as ET
    from datetime import datetime
    directory = os.path.join(nmapdir)
    if os.path.isdir(directory):
        for xmlfile in os.listdir(directory):
            if xmlfile.endswith('.xml'):
                f = open(os.path.join(directory,xmlfile), 'r')
                lastline = f.read().splitlines()[-1]
                f.close()
                status = ""
                if lastline == "</nmaprun>":
                    status = "Completed"
                elif "taskprogress" in lastline:
                    tree = ET.ElementTree(lastline)
                    root = ET.fromstring(lastline)
                    for name,value in root.attrib.items():
                        if name in ["time","etc"]:
                            value = datetime.fromtimestamp(int(value))
                        status += "\n   "+name+": "+str(value)

                else:
                    status = "Running"
                print(xmlfile+": "+status)
                



def xmlimport(xmlfile):
    import xml.etree.ElementTree as ET
    con = lite.connect(db)

    try:
        tree = ET.ElementTree(file = xmlfile)
        root = tree.getroot()
    except:
        print("[!] Error parsing XML from: "+xmlfile)
        return

    #Create Database tables
    cur = con.cursor()
    cur.row_factory = lambda cursor, row: row[0]
    try:
        cur.execute("CREATE TABLE openports (ip varchar(16), port integer(5), protocol varchar(3), service varchar(100), tunnel varchar(4), version varchar(100));")
        cur.execute("CREATE TABLE closedports (ip varchar(16), port integer(5), range varchar(100), protocol varchar(3));")
        cur.execute("CREATE TABLE hostnames (hostname varchar(500), ip varchar(16));")
        cur.execute("CREATE TABLE osmatch (name varchar(100), accuracy int(3), ip varchar(16));")
        cur.execute("CREATE TABLE scripts (id varchar(100), ip varchar(16), port integer(5), output varchar(512));")
        cur.execute("CREATE UNIQUE INDEX opencheck ON openports (ip,port,protocol);")
        cur.execute("CREATE UNIQUE INDEX closedcheckip ON closedports (ip,port,protocol);")
        cur.execute("CREATE UNIQUE INDEX closedcheckrange ON closedports (ip,range,protocol);")
        cur.execute("CREATE UNIQUE INDEX scriptcheck ON scripts (id,ip,port);")
        cur.execute("CREATE UNIQUE INDEX hostnamecheck ON hostnames (hostname,ip);")
        cur.execute("CREATE UNIQUE INDEX osmatchcheck ON osmatch (name,accuracy,ip);")
    except Exception as e:
        pass

    # Loop through and pull out the data for the db

    # Get IP Address and hostnames
    for host in root.iterfind('host'):
        ip = host.find("./address").attrib['addr']
        hostname = []
        try:
            for name in host.find("./hostnames"):
                hostname.append(name.attrib['name'])
        except:
            pass
        osmatch =[]
        try:
            for match in host.findall("./os/osmatch"):
                name = match.attrib['name']
                accuracy = match.attrib['accuracy']
                osmatch.append((name,accuracy))
        except:
            pass
    
        # Identifies batches of closed ports    
        for extraport in host.findall("./ports/extraports"):
            if extraport.attrib['state'] == "closed":
                closed_protocol=extraport.find("./extrareasons").attrib['proto']
                closed_ports=extraport.find("./extrareasons").attrib['ports']
                try:
                    cur.execute("INSERT INTO closedports (ip,protocol,range) values (?,?,?)",(ip,closed_protocol,closed_ports)) 
                except Exception as e:
                    pass
        
        # Hostnames into database
        if hostname:
            for name in hostname:
                try:
                    cur.execute("INSERT INTO hostnames (hostname,ip) VALUES (?,?)",(str(name),ip))
                except:
                    pass
        
        # OS Match into database
        if osmatch:
            for name,accuracy in osmatch:
                try:
                    cur.execute("INSERT INTO osmatch (name,accuracy,ip) VALUES (?,?,?)",(str(name),str(accuracy),ip))
                except Exception as e:
                    pass

        # Work through each port in the nmap output
        for openport in host.iter('port'):
            port = openport.attrib['portid']
            protocol = openport.attrib['protocol']
            state = openport.find("./state").attrib['state']
            try: service = openport.find("./service").attrib['name']
            except: service = "empty"
            try: tunnel = openport.find("./service").attrib['tunnel']
            except: tunnel="none"
            try: product = openport.find("./service").attrib['product'] 
            except: product=""
            try: productversion = openport.find("./service").attrib['version']
            except: productversion=""

            # Scripts
            for script in openport.findall('script'):
                sid = script.attrib['id']
                soutput = script.attrib['output']
                try:
                    cur.execute("INSERT INTO scripts (id,ip,port,output) VALUES (?,?,?,?)",(sid,ip,port,soutput))
                except Exception as e:
                    pass

             #enter into db
            if state == "open":
                dbtable = "openports"
                try:
                    cur.execute("INSERT INTO "+dbtable+" (ip,port,protocol,service,tunnel,version) values (?,?,?,?,?,?)",(ip,port,protocol,service,tunnel,product+' '+productversion)) 
                except:
                    pass
            elif state == "closed":
                dbtable = "closedports"
                try:
                    cur.execute("INSERT INTO "+dbtable+" (ip,port,protocol) values (?,?,?)",(ip,port,protocol)) 
                except:
                    pass
        
    con.commit()

# Gets hostnames from an IP
def gethostnames(ip):
    con=lite.connect(db)
    con.row_factory = lite.Row
    cur = con.cursor()
    hostnamelist = []
    try:
        response = cur.execute("select hostname from hostnames where ip='"+ip+"';").fetchall()
        for row in response:
            hostnamelist.append(row['hostname'])
    except:
        pass
    return(hostnamelist)


# Finds any port with SSL listening and adds them to the service array     
def findssl():
    print("[+] SSL port identification")
    con=lite.connect(db)
    con.row_factory = lite.Row
    cur = con.cursor()
    cur.execute('select ip,port from openports where tunnel="ssl" and protocol="tcp";')
    ssldb = cur.fetchall()
    if ssldb:
        nowlist=[]
        for row in ssldb:
            ip = row['ip']
            port = str(row['port'])
            nowlist.append(ip+":"+port)
            hnlist = gethostnames(ip)
            for hn in list(hnlist):
                nowlist.append(hn+":"+port)
        servicearray['sslport']={"tcp": nowlist}
        print("   [*] Found "+str(len(nowlist))+" SSL ports")

# Finds any closed ports and adds them to the service array
def findclosed():
    print("[+] Closed port identification")
    con=lite.connect(db)
    con.row_factory = lite.Row
    cur = con.cursor()
    cur.execute('select * from closedports;')
    closeddb = cur.fetchall()
    if closeddb:
        nowlist=[]
        for row in closeddb:
            cip = row['ip']
            cport = row['port']
            crange = row['range']
            cprotocol = row['protocol']
            if cport is None:
                string = cip+":"+crange+":"+cprotocol
            elif crange is None:
                string = cip+":"+str(cport)+":"+cprotocol
            nowlist.append(string)
        servicearray['closed']={"": nowlist}
        print("   [*] Found "+str(len(nowlist))+" closed ports/ranges")

# Identifies HTTP and HTTPS and put them into the service array
def findhttp(SSL):
    con=lite.connect(db)
    con.row_factory = lite.Row
    cur = con.cursor()
    if SSL == '1':
        print("[+] HTTPS identification")
        tunnel='ssl'
        service='securehttp'
    else:
        print("[+] HTTP identification")
        tunnel='none'
        service='plainhttp'
    cur.execute('SELECT ip,port FROM openports WHERE service like "%http%" and tunnel="'+tunnel+'" and protocol="tcp";')
    httpdb=cur.fetchall()
    nowlist=[]
    if httpdb:
        for row in httpdb:
            ip = row['ip']
            port = str(row['port'])
            nowlist.append(ip+":"+port)
            hnlist = gethostnames(ip)
            for hn in list(hnlist):
                nowlist.append(hn+":"+port)
        servicearray[service]={"tcp": nowlist}
        print("   [*] Found "+str(len(nowlist))+" "+service+" ports")

def findservices():
    global servicearray
    print("[+] Enumerating services")
    con=lite.connect(db)
    cur = con.cursor()
    cur.execute('SELECT distinct service,protocol FROM openports;')
    servicelist = cur.fetchall()
    for service,protocol in servicelist:
        cur.execute('SELECT ip ||":"|| port FROM openports WHERE service="'+service+'"and protocol="'+protocol+'";')
        hostports=cur.fetchall()
        nowlist=[]
        if service not in servicearray:
            servicearray[service]={}
        for line in hostports:
            nowlist.extend(line)
        servicearray[service][protocol]=nowlist
    print("   [*] Found "+str(len(servicelist))+" distinct services")
    findssl()
    findhttp(0)
    findhttp("1")
    findclosed()

# Writes the services out as an array to file
def outputarray():
    obfile = open (os.path.join(args.output,svcarrayfile), 'w')
    obfile.write(str(servicearray))
    obfile.close



# Writes the output to files            
def outputfiles():
    location = args.output
    servicedir = os.path.join(location, svcfolder)
    try:
        os.mkdir(servicedir)
    except OSError:
        print("[!] Output folder already exists")
        return
    for service in servicearray:
        for protocol,hostports in servicearray[service].items():
            if len(hostports) > 0:
                protocoldir = os.path.join(servicedir,protocol)
                try: os.mkdir(protocoldir)
                except: pass
                filename=service.replace('/','_')+'.service'
                prefix=""
                if service=="sslport":
                    filename="ssl.host"
                elif service=="securehttp":
                    filename="webapp.url.https"
                    prefix="https://"
                elif service=="plainhttp":
                    filename="webapp.url.http"
                    prefix="http://"
            
                sfile = open (os.path.join(protocoldir, filename), 'w')
                for line in hostports:
                    sfile.write(prefix+str(line)+"\n")
                sfile.close

    # Makes a directory for informational output
    infodir = os.path.join(location, "info")
    try:
        os.mkdir(infodir)
    except:
        pass

    # Write the ports for nessus/nmap to file
    con=lite.connect(db)
    con.row_factory = lite.Row
    cur = con.cursor()
    port_list = cur.execute('SELECT distinct port,protocol from openports;').fetchall()
    if port_list:
        tcplist=[]
        udplist=[]
        for row in port_list:
            port = str(row['port'])
            protocol = row['protocol']
            if protocol == "tcp":
                tcplist.append(port)
            elif protocol == "udp":
                udplist.append(port)
                
        openfile = open (os.path.join(infodir,"nessus.ports"), 'w')
        if tcplist:
            openfile.write("T:"+",".join(tcplist))
        if tcplist and udplist:
            openfile.write(",")
        if udplist:
            openfile.write("U:"+",".join(udplist))
        openfile.close()

    # Write OS matches and identified software versions to file
    con=lite.connect(db)
    con.row_factory = lite.Row
    cur = con.cursor()
    ip_list = cur.execute('SELECT distinct ip from openports;').fetchall()
    for row in ip_list:
        ip = row['ip']
        osmatches = cur.execute('SELECT name,accuracy FROM osmatch where ip="'+str(ip)+'";').fetchall()
        port_list = cur.execute('SELECT port,protocol,version from openports where version!=NULL and ip="'+str(ip)+'";').fetchall()
        if osmatches or port_list:
            openfile = open (os.path.join(infodir,ip+".info"), 'w')
        if osmatches:
            openfile.write("OS Matches\n")
            for name,accuracy in osmatches:
                openfile.write(str(accuracy)+"%  : "+name+"\n")
            openfile.write("\n\n")
        if port_list:
            openfile.write("Detected Software Versions\n")
            for port,protocol,version in port_list:
                if version != " ":
                    openfile.write(str(port)+"/"+protocol+"   "+version+"\n")
                    
    # Writes script output to files
    con=lite.connect(db)
    con.row_factory = lite.Row
    cur = con.cursor()
    ip_list = cur.execute('SELECT distinct ip from scripts;').fetchall()
    if ip_list:
        scriptdir = os.path.join(location, "scripts")
        try:
            os.mkdir(scriptdir)
        except:
            pass
        for row in ip_list:
            ip = row['ip']
            script_list = cur.execute('SELECT id,port,output from scripts where ip="'+ip+'";').fetchall()
            ipdir = os.path.join(scriptdir, str(ip))
            os.mkdir(ipdir)
            for id,port,output in script_list:
                openfile = open (os.path.join(ipdir,str(id)), 'w')
                openfile.write(ip+":"+str(port)+"\n\n")
                openfile.write(str(output)+"\n")
                openfile.close

def filehandler(arginput):
    if os.path.isfile(arginput):
        xmlimport(arginput)
    elif os.path.isdir(arginput):
        for xmlfile in os.listdir(arginput):
            if xmlfile.endswith('.xml'):
                xmlimport(os.path.join(args.xml ,xmlfile))

if __name__ == "__main__":
    if args.mode == "parse":
        filehandler(args.xml)
        findservices()
        outputarray()
        outputfiles()
    if args.mode == "monitor":
        nmap_xml_monitor(args.xml)
