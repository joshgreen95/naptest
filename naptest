#!/usr/bin/python3
#naptest- not another pentest!

import sys,sqlite3 as lite,os,argparse,ast

parser = argparse.ArgumentParser(prog='naptest')
subparsers = parser.add_subparsers(help='sub-command help')

parser_scope = subparsers.add_parser('scope', help="scope mode will create a list of IPs from a list of ranges.")
parser_scope.set_defaults(dest="scope")
parser_scope.add_argument("input", help="File containing scope")
parser_scope.add_argument("-p" , "--print", help="Print the IPs in scope", action="store_true")
parser_scope.add_argument("-o", "--output", help="directory for output", default="./")
parser_scope.add_argument("-e", "--exclude", help="IPs to exclude. Comma separated.")
parser_scope.add_argument("-a", "--autoexclude", help="Automatically exclude all your IPs (from all interfaces).", action="store_true")

parser_scan = subparsers.add_parser('scan', help="scan mode will use arp-scan and nmap to identify live hosts.")
parser_scan.set_defaults(dest="scan")
parser_scan.add_argument("-o", "--output", help="directory for output", default="./")

parser_parse = subparsers.add_parser('parse', help="parse mode will generate output based on completed nmap scans.")
parser_parse.add_argument("xml", help="directory containing nmap output")
parser_parse.add_argument("-o", "--output", help="directory for output", default="./")
parser_parse.set_defaults(dest="parse")

parser_status = subparsers.add_parser('status', help="status mode will show you the status of nmap scans.")
parser_status.add_argument("directory", help="directory containing nmap output")
parser_status.set_defaults(dest="status")

global args
args = parser.parse_args()



#Magic Variables
dbfile="naptest.db"
svcarrayfile="services.array"
svcfolder="services"

def get_system_ips():
    import ipaddress,netifaces as ni
    ips = {}
    for nic in ni.interfaces():
        try:
            ip =  ni.ifaddresses(nic)[ni.AF_INET][0]['addr']
            ips[ip] = nic
        except:
            pass
    return ips


def db_connect():
    con = lite.connect(db)
    cur = con.cursor()
    cur.execute("SELECT name FROM sqlite_schema WHERE type='table' ORDER BY name;")
    tables = cur.fetchall()
    if not tables:
        try:
            cur.execute("CREATE TABLE scope (ip varchar(16), network varchar(19), live integer(1), status varchar(20));")
            cur.execute("CREATE TABLE openports (ip varchar(16), port integer(5), protocol varchar(3), service varchar(100), tunnel varchar(4), version varchar(100));")
            cur.execute("CREATE TABLE closedports (ip varchar(16), port integer(5), range varchar(100), protocol varchar(3));")
            cur.execute("CREATE TABLE hostnames (hostname varchar(500), ip varchar(16));")
            cur.execute("CREATE TABLE osmatch (name varchar(100), accuracy int(3), ip varchar(16));")
            cur.execute("CREATE TABLE scripts (id varchar(100), ip varchar(16), port integer(5), output varchar(512));")
            cur.execute("CREATE UNIQUE INDEX scopedip ON scope (ip);")
            cur.execute("CREATE UNIQUE INDEX opencheck ON openports (ip,port,protocol);")
            cur.execute("CREATE UNIQUE INDEX closedcheckip ON closedports (ip,port,protocol);")
            cur.execute("CREATE UNIQUE INDEX closedcheckrange ON closedports (ip,range,protocol);")
            cur.execute("CREATE UNIQUE INDEX scriptcheck ON scripts (id,ip,port);")
            cur.execute("CREATE UNIQUE INDEX hostnamecheck ON hostnames (hostname,ip);")
            cur.execute("CREATE UNIQUE INDEX osmatchcheck ON osmatch (name,accuracy,ip);")
        except Exception as e:
            pass
    return con

def scope_generator(file):
    import ipaddress
    exclusions = []
    if args.autoexclude:
        exclusions += list(get_system_ips().keys())
    con = db_connect()
    cur = con.cursor()
    f = open(file,'r')
    scope = f.readlines()
    f.close()
    scope_ips = []
    if args.exclude:
        exclusions += args.exclude.split(',')
    for line in scope:
        scoped = line.strip()
        network = ipaddress.ip_network(scoped, strict=False)
        for ip in network:
            if str(ip) not in exclusions:
                scope_ips.append(ip)
                try:
                    cur.execute("INSERT INTO scope (ip,network,status) values (?,?,?)",(str(ip),str(network),"new"))
                except Exception as error:
                    pass
    con.commit()
    if args.print:
        for ip in scope_ips:
            print(ip)

def findlocalranges():
    import ipaddress
    con = db_connect()
    cur = con.cursor()
    #cur.row_factory = str
    cur.execute("select distinct network from scope;")
    networks = cur.fetchall()
    systemips = get_system_ips()
    results = {}
    for ip in systemips.keys():
        ip = "".join(ip)
        for network in networks:
            network = "".join(network)
            if ipaddress.ip_address(ip) in ipaddress.ip_network(network):
                interface = systemips[ip]
                results[interface] = network
    return results

def arpscan(targets):
    for interface,network in targets.items():
        print(interface+":"+network)
        scan = os.popen("echo 127.0.0.2;echo 127.0.0.3;echo 127.0.0.1")
        output = scan.readlines()
        for line in output:
            ip = line.strip()
            print(ip)
            con = db_connect()
            cur = con.cursor()
            cur.execute("UPDATE scope set live = '1' where ip = ?",(ip,))
        con.commit()





def nmap_xml_monitor(nmapdir):
    import re
    import xml.etree.ElementTree as ET
    import datetime
    directory = os.path.join(nmapdir)
    if os.path.isdir(directory):
        nmap_status = {}
        for xmlfile in os.listdir(directory):
            if xmlfile.endswith('.xml'):
                f = open(os.path.join(directory,xmlfile), 'r')
                lastlines = f.read().splitlines()[-3:]
                f.close()
                nmap_status[xmlfile] = {}
                status = ""
                lastline = lastlines[2]
                if lastline == "</nmaprun>":
                    stats = "".join(lastlines[0:2])
                    root = ET.fromstring(stats)
                    hosts = root.find('hosts')
                    up = hosts.attrib['up']
                    total = hosts.attrib['total']
                    status = "Completed"
                    details = {'up':up,'total':total}

                elif "taskprogress" in lastline:
                    tree = ET.ElementTree(lastline)
                    root = ET.fromstring(lastline)
                    status = "In Progress"
                    details = {}
                    for name,value in root.attrib.items():
                        if name in ["time","etc"]:
                            value = datetime.datetime.fromtimestamp(int(value))
                        details[name] = value
                        

                else:
                    status = "Running"
                nmap_status[xmlfile] = {'status':status,'details':details}
        completed = []
        livehosts = 0
        scannedhosts = 0
        inprogress = {}
        running = []
        for scan,values in nmap_status.items():
            status = values['status']
            details = values['details']
            if status == "Completed":
                completed.append(scan)
                livehosts = livehosts + int(details['up'])
                scannedhosts = scannedhosts + int(details['total'])
            if status == "In Progress":
                try:
                    etc = details['etc']
                    inprogress[etc] = scan
                except:
                    status = "Running"
            if status == "Running":
                running.append(scan)
        if completed:
            #print("The following "+str(len(completed))+" completed scans have found "+str(livehosts)+"/"+str(scannedhosts)+" live hosts.\n\n"+", ".join(completed)+"\n")
            print(str(len(completed))+" completed scans have found "+str(livehosts)+"/"+str(scannedhosts)+" live hosts.\n\n")
        if inprogress:
            times = [60,300,600,3600,7200,21600]
            now = datetime.datetime.now()
            etclist = list(inprogress.keys())
            etclist.sort()
            previndex = 0
            print("The following scans are in progress:\n")
            for i,etc in enumerate(etclist):
                topindex = i
                timeremaining = etc - now
                if timeremaining.total_seconds() < 0:
                    timeremaining = "Now"
                print(str(timeremaining).split(".")[0]+": "+inprogress[etc]+" ("+nmap_status[inprogress[etc]]['details']['task']+")")

        if running:
            print("The following scans are running without progress available at this time:\n"+"\n".join(running))




def xmlimport(xmlfile):
    import xml.etree.ElementTree as ET
    con = db_connect()
    cur = con.cursor()
    cur.row_factory = lambda cursor, row: row[0]

    try:
        tree = ET.ElementTree(file = xmlfile)
        root = tree.getroot()
    except:
        print("[!] Error parsing XML from: "+xmlfile)
        return


    # Loop through and pull out the data for the db

    # Get IP Address and hostnames
    for host in root.iterfind('host'):
        ip = host.find("./address").attrib['addr']
        hostname = []
        try:
            for name in host.find("./hostnames"):
                hostname.append(name.attrib['name'])
        except:
            pass
        osmatch =[]
        try:
            for match in host.findall("./os/osmatch"):
                name = match.attrib['name']
                accuracy = match.attrib['accuracy']
                osmatch.append((name,accuracy))
        except:
            pass
        cur.execute("UPDATE scope set status = 'scanned' where ip = ?",(ip,))
    
        # Identifies batches of closed ports    
        for extraport in host.findall("./ports/extraports"):
            if extraport.attrib['state'] == "closed":
                closed_protocol=extraport.find("./extrareasons").attrib['proto']
                closed_ports=extraport.find("./extrareasons").attrib['ports']
                try:
                    cur.execute("INSERT INTO closedports (ip,protocol,range) values (?,?,?)",(ip,closed_protocol,closed_ports)) 
                except Exception as e:
                    pass
        
        # Hostnames into database
        if hostname:
            for name in hostname:
                try:
                    cur.execute("INSERT INTO hostnames (hostname,ip) VALUES (?,?)",(str(name),ip))
                except:
                    pass
        
        # OS Match into database
        if osmatch:
            for name,accuracy in osmatch:
                try:
                    cur.execute("INSERT INTO osmatch (name,accuracy,ip) VALUES (?,?,?)",(str(name),str(accuracy),ip))
                except Exception as e:
                    pass

        # Work through each port in the nmap output
        for openport in host.iter('port'):
            port = openport.attrib['portid']
            protocol = openport.attrib['protocol']
            state = openport.find("./state").attrib['state']
            try: service = openport.find("./service").attrib['name']
            except: service = "empty"
            try: tunnel = openport.find("./service").attrib['tunnel']
            except: tunnel="none"
            try: product = openport.find("./service").attrib['product'] 
            except: product=""
            try: productversion = openport.find("./service").attrib['version']
            except: productversion=""

            # Scripts
            for script in openport.findall('script'):
                sid = script.attrib['id']
                soutput = script.attrib['output']
                try:
                    cur.execute("INSERT INTO scripts (id,ip,port,output) VALUES (?,?,?,?)",(sid,ip,port,soutput))
                except Exception as e:
                    pass

             #enter into db
            if state == "open":
                dbtable = "openports"
                try:
                    cur.execute("INSERT INTO "+dbtable+" (ip,port,protocol,service,tunnel,version) values (?,?,?,?,?,?)",(ip,port,protocol,service,tunnel,product+' '+productversion)) 
                except:
                    pass
            elif state == "closed":
                dbtable = "closedports"
                try:
                    cur.execute("INSERT INTO "+dbtable+" (ip,port,protocol) values (?,?,?)",(ip,port,protocol)) 
                except:
                    pass
        
    con.commit()

# Gets hostnames from an IP
def gethostnames(ip):
    con=lite.connect(db)
    con.row_factory = lite.Row
    cur = con.cursor()
    hostnamelist = []
    try:
        response = cur.execute("select hostname from hostnames where ip='"+ip+"';").fetchall()
        for row in response:
            hostnamelist.append(row['hostname'])
    except:
        pass
    return(hostnamelist)


# Finds any port with SSL listening and adds them to the service array     
def findssl():
    print("[+] SSL port identification")
    con=lite.connect(db)
    con.row_factory = lite.Row
    cur = con.cursor()
    cur.execute('select ip,port from openports where tunnel="ssl" and protocol="tcp";')
    ssldb = cur.fetchall()
    if ssldb:
        nowlist=[]
        for row in ssldb:
            ip = row['ip']
            port = str(row['port'])
            nowlist.append(ip+":"+port)
            hnlist = gethostnames(ip)
            for hn in list(hnlist):
                nowlist.append(hn+":"+port)
        servicearray['sslport']={"tcp": nowlist}
        print("   [*] Found "+str(len(nowlist))+" SSL ports")

# Finds any closed ports and adds them to the service array
def findclosed():
    print("[+] Closed port identification")
    con=lite.connect(db)
    con.row_factory = lite.Row
    cur = con.cursor()
    cur.execute('select * from closedports;')
    closeddb = cur.fetchall()
    if closeddb:
        nowlist=[]
        for row in closeddb:
            cip = row['ip']
            cport = row['port']
            crange = row['range']
            cprotocol = row['protocol']
            if cport is None:
                string = cip+":"+crange+":"+cprotocol
            elif crange is None:
                string = cip+":"+str(cport)+":"+cprotocol
            nowlist.append(string)
        servicearray['closed']={"": nowlist}
        print("   [*] Found "+str(len(nowlist))+" closed ports/ranges")

# Identifies HTTP and HTTPS and put them into the service array
def findhttp(SSL):
    con=lite.connect(db)
    con.row_factory = lite.Row
    cur = con.cursor()
    if SSL == '1':
        print("[+] HTTPS identification")
        tunnel='ssl'
        service='securehttp'
    else:
        print("[+] HTTP identification")
        tunnel='none'
        service='plainhttp'
    cur.execute('SELECT ip,port FROM openports WHERE service like "%http%" and tunnel="'+tunnel+'" and protocol="tcp";')
    httpdb=cur.fetchall()
    nowlist=[]
    if httpdb:
        for row in httpdb:
            ip = row['ip']
            port = str(row['port'])
            nowlist.append(ip+":"+port)
            hnlist = gethostnames(ip)
            for hn in list(hnlist):
                nowlist.append(hn+":"+port)
        servicearray[service]={"tcp": nowlist}
        print("   [*] Found "+str(len(nowlist))+" "+service+" ports")

def findservices():
    global servicearray
    print("[+] Enumerating services")
    con=lite.connect(db)
    cur = con.cursor()
    cur.execute('SELECT distinct service,protocol FROM openports;')
    servicelist = cur.fetchall()
    for service,protocol in servicelist:
        cur.execute('SELECT ip ||":"|| port FROM openports WHERE service="'+service+'"and protocol="'+protocol+'";')
        hostports=cur.fetchall()
        nowlist=[]
        if service not in servicearray:
            servicearray[service]={}
        for line in hostports:
            nowlist.extend(line)
        servicearray[service][protocol]=nowlist
    print("   [*] Found "+str(len(servicelist))+" distinct services")
    findssl()
    findhttp(0)
    findhttp("1")
    findclosed()

# Writes the services out as an array to file
def outputarray():
    obfile = open (os.path.join(args.output,svcarrayfile), 'w')
    obfile.write(str(servicearray))
    obfile.close



# Writes the output to files            
def outputfiles():
    location = args.output
    servicedir = os.path.join(location, svcfolder)
    try:
        os.mkdir(servicedir)
    except OSError:
        print("[!] Output folder already exists")
        return
    for service in servicearray:
        for protocol,hostports in servicearray[service].items():
            if len(hostports) > 0:
                protocoldir = os.path.join(servicedir,protocol)
                try: os.mkdir(protocoldir)
                except: pass
                filename=service.replace('/','_')+'.service'
                prefix=""
                if service=="sslport":
                    filename="ssl.host"
                elif service=="securehttp":
                    filename="webapp.url.https"
                    prefix="https://"
                elif service=="plainhttp":
                    filename="webapp.url.http"
                    prefix="http://"
            
                sfile = open (os.path.join(protocoldir, filename), 'w')
                for line in hostports:
                    sfile.write(prefix+str(line)+"\n")
                sfile.close

    # Makes a directory for informational output
    infodir = os.path.join(location, "info")
    try:
        os.mkdir(infodir)
    except:
        pass

    # Write the ports for nessus/nmap to file
    con=lite.connect(db)
    con.row_factory = lite.Row
    cur = con.cursor()
    port_list = cur.execute('SELECT distinct port,protocol from openports;').fetchall()
    if port_list:
        tcplist=[]
        udplist=[]
        for row in port_list:
            port = str(row['port'])
            protocol = row['protocol']
            if protocol == "tcp":
                tcplist.append(port)
            elif protocol == "udp":
                udplist.append(port)
                
        openfile = open (os.path.join(infodir,"nessus.ports"), 'w')
        if tcplist:
            openfile.write("T:"+",".join(tcplist))
        if tcplist and udplist:
            openfile.write(",")
        if udplist:
            openfile.write("U:"+",".join(udplist))
        openfile.close()
    
    # Writes live IPs to file
    con=lite.connect(db)
    con.row_factory = None
    con.text_factory = str
    cur = con.cursor()
    ip_list = cur.execute('select distinct ip from openports union select distinct ip from closedports;').fetchall()
    openfile = open (os.path.join(infodir,"live.ips"), 'w')
    for ip in ip_list:
        openfile.write(''.join(ip)+"\n")
    openfile.close()

    # Write OS matches and identified software versions to file
    con=lite.connect(db)
    con.row_factory = lite.Row
    cur = con.cursor()
    ip_list = cur.execute('SELECT distinct ip from openports;').fetchall()
    for row in ip_list:
        ip = row['ip']
        osmatches = cur.execute('SELECT name,accuracy FROM osmatch where ip="'+str(ip)+'";').fetchall()
        port_list = cur.execute('SELECT port,protocol,version from openports where version!=NULL and ip="'+str(ip)+'";').fetchall()
        if osmatches or port_list:
            openfile = open (os.path.join(infodir,ip+".info"), 'w')
        if osmatches:
            openfile.write("OS Matches\n")
            for name,accuracy in osmatches:
                openfile.write(str(accuracy)+"%  : "+name+"\n")
            openfile.write("\n\n")
        if port_list:
            openfile.write("Detected Software Versions\n")
            for port,protocol,version in port_list:
                if version != " ":
                    openfile.write(str(port)+"/"+protocol+"   "+version+"\n")
                    
    # Writes script output to files
    con=lite.connect(db)
    con.row_factory = lite.Row
    cur = con.cursor()
    ip_list = cur.execute('SELECT distinct ip from scripts;').fetchall()
    if ip_list:
        scriptdir = os.path.join(location, "scripts")
        try:
            os.mkdir(scriptdir)
        except:
            pass
        for row in ip_list:
            ip = row['ip']
            script_list = cur.execute('SELECT id,port,output from scripts where ip="'+ip+'";').fetchall()
            ipdir = os.path.join(scriptdir, str(ip))
            os.mkdir(ipdir)
            for id,port,output in script_list:
                openfile = open (os.path.join(ipdir,str(id)), 'w')
                openfile.write(ip+":"+str(port)+"\n\n")
                openfile.write(str(output)+"\n")
                openfile.close

def filehandler(arginput):
    if os.path.isfile(arginput):
        xmlimport(arginput)
    elif os.path.isdir(arginput):
        for xmlfile in os.listdir(arginput):
            if xmlfile.endswith('.xml'):
                xmlimport(os.path.join(args.xml ,xmlfile))

if __name__ == "__main__":
    try:
        args.dest
    except:
        print("Please select a subcommand")
        exit(1)
    if args.dest == "parse":
        db = os.path.join(args.output, dbfile)
        global servicearray
        servicearray = {}
        filehandler(args.xml)
        findservices()
        outputarray()
        outputfiles()
    elif args.dest == "status":
        nmap_xml_monitor(args.directory)
    elif args.dest == "scope":
        db = os.path.join(args.output, dbfile)
        scope_generator(args.input)
    elif args.dest == "scan":
        db = os.path.join(args.output, dbfile)
        arpscantargets = findlocalranges()
        arpscan(arpscantargets)
